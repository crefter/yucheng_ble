// Autogenerated from Pigeon (v25.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

enum class YuchengSleepType(val raw: Int) {
  REM(0),
  DEEP(1),
  AWAKE(2),
  LIGHT(3),
  UNKNOWN(4);

  companion object {
    fun ofRaw(raw: Int): YuchengSleepType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class YuchengProductState(val raw: Int) {
  UNKNOWN(0),
  CONNECTED(1),
  CONNECTED_FAILED(2),
  DISCONNECTED(3),
  UNAVAILABLE(4),
  READ_WRITE_OK(5),
  TIME_OUT(6);

  companion object {
    fun ofRaw(raw: Int): YuchengProductState? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class YuchengSleepEvent 
/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengSleepDataEvent (
  /** Начало сна в мс */
  val startTimeStamp: Long,
  /** Конец сна в мс */
  val endTimeStamp: Long,
  /** Если равен 0xFFFF, то новый формат в секундах, иначе старый в минутах */
  val deepCount: Long,
  val lightCount: Long,
  val awakeCount: Long,
  val deepInSeconds: Long,
  val remInSeconds: Long,
  val lightInSeconds: Long,
  val awakeInSeconds: Long,
  val details: List<YuchengSleepDataDetail>
) : YuchengSleepEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengSleepDataEvent {
      val startTimeStamp = pigeonVar_list[0] as Long
      val endTimeStamp = pigeonVar_list[1] as Long
      val deepCount = pigeonVar_list[2] as Long
      val lightCount = pigeonVar_list[3] as Long
      val awakeCount = pigeonVar_list[4] as Long
      val deepInSeconds = pigeonVar_list[5] as Long
      val remInSeconds = pigeonVar_list[6] as Long
      val lightInSeconds = pigeonVar_list[7] as Long
      val awakeInSeconds = pigeonVar_list[8] as Long
      val details = pigeonVar_list[9] as List<YuchengSleepDataDetail>
      return YuchengSleepDataEvent(startTimeStamp, endTimeStamp, deepCount, lightCount, awakeCount, deepInSeconds, remInSeconds, lightInSeconds, awakeInSeconds, details)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      startTimeStamp,
      endTimeStamp,
      deepCount,
      lightCount,
      awakeCount,
      deepInSeconds,
      remInSeconds,
      lightInSeconds,
      awakeInSeconds,
      details,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengSleepDataDetail (
  /** Начало в мс */
  val startTimeStamp: Long,
  /** Длительность в мс */
  val duration: Long,
  /** Тип сна */
  val type: YuchengSleepType
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengSleepDataDetail {
      val startTimeStamp = pigeonVar_list[0] as Long
      val duration = pigeonVar_list[1] as Long
      val type = pigeonVar_list[2] as YuchengSleepType
      return YuchengSleepDataDetail(startTimeStamp, duration, type)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      startTimeStamp,
      duration,
      type,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengSleepErrorEvent (
  val error: String
) : YuchengSleepEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengSleepErrorEvent {
      val error = pigeonVar_list[0] as String
      return YuchengSleepErrorEvent(error)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      error,
    )
  }
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class YuchengDeviceStateEvent 
/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengDeviceStateDataEvent (
  val state: YuchengProductState
) : YuchengDeviceStateEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengDeviceStateDataEvent {
      val state = pigeonVar_list[0] as YuchengProductState
      return YuchengDeviceStateDataEvent(state)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      state,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengDeviceStateErrorEvent (
  val state: YuchengProductState,
  val error: String
) : YuchengDeviceStateEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengDeviceStateErrorEvent {
      val state = pigeonVar_list[0] as YuchengProductState
      val error = pigeonVar_list[1] as String
      return YuchengDeviceStateErrorEvent(state, error)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      state,
      error,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengDevice (
  val index: Long,
  val deviceName: String,
  /**
   * Android - тут mac address для подключения
   * IOS - uuid девайса
   */
  val uuid: String,
  /**
   * true - уже изначально подключен
   * false - не был подключен изначально, нужно подключить
   */
  val isCurrentConnected: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengDevice {
      val index = pigeonVar_list[0] as Long
      val deviceName = pigeonVar_list[1] as String
      val uuid = pigeonVar_list[2] as String
      val isCurrentConnected = pigeonVar_list[3] as Boolean
      return YuchengDevice(index, deviceName, uuid, isCurrentConnected)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      index,
      deviceName,
      uuid,
      isCurrentConnected,
    )
  }
}

/**
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class YuchengDeviceEvent 
/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengDeviceDataEvent (
  val index: Long,
  /**
   * ДЛЯ ANDROID
   * Нужен, чтобы подключиться к девайсу
   * ДЛЯ IOS
   * Uuid девайса
   */
  val mac: String,
  /**
   * Только IOS
   * true - уже изначально подключен
   * false - не был подключен изначально, нужно подключить
   */
  val isCurrentConnected: Boolean? = null,
  val deviceName: String
) : YuchengDeviceEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengDeviceDataEvent {
      val index = pigeonVar_list[0] as Long
      val mac = pigeonVar_list[1] as String
      val isCurrentConnected = pigeonVar_list[2] as Boolean?
      val deviceName = pigeonVar_list[3] as String
      return YuchengDeviceDataEvent(index, mac, isCurrentConnected, deviceName)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      index,
      mac,
      isCurrentConnected,
      deviceName,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class YuchengDeviceCompleteEvent (
  val completed: Boolean
) : YuchengDeviceEvent()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): YuchengDeviceCompleteEvent {
      val completed = pigeonVar_list[0] as Boolean
      return YuchengDeviceCompleteEvent(completed)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      completed,
    )
  }
}
private open class YuchengBleApiPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          YuchengSleepType.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          YuchengProductState.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengSleepDataEvent.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengSleepDataDetail.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengSleepErrorEvent.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengDeviceStateDataEvent.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengDeviceStateErrorEvent.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengDevice.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengDeviceDataEvent.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          YuchengDeviceCompleteEvent.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is YuchengSleepType -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is YuchengProductState -> {
        stream.write(130)
        writeValue(stream, value.raw)
      }
      is YuchengSleepDataEvent -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is YuchengSleepDataDetail -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is YuchengSleepErrorEvent -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is YuchengDeviceStateDataEvent -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is YuchengDeviceStateErrorEvent -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is YuchengDevice -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is YuchengDeviceDataEvent -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is YuchengDeviceCompleteEvent -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

val YuchengBleApiPigeonMethodCodec = StandardMethodCodec(YuchengBleApiPigeonCodec());


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface YuchengHostApi {
  /**
   * [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды для ios и 10 для андройд)
   * Прослушивать стрим devices
   *
   * Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
   * на bluetooth
   */
  fun startScanDevices(scanTimeInSeconds: Double?, callback: (Result<List<YuchengDevice>>) -> Unit)
  /**
   * Работает для IOS, для андройд будет просто проверка, подключен ли какой-либо девайс к сдк
   * [device] - девайс, который нужно проверить
   * Проверяет, подключен ли данный девайс
   */
  fun isDeviceConnected(device: YuchengDevice?, callback: (Result<Boolean>) -> Unit)
  /** Подключить девайс к сдк */
  fun connect(device: YuchengDevice, callback: (Result<Boolean>) -> Unit)
  fun reconnect(callback: (Result<Boolean>) -> Unit)
  /** Отключить девайс от сдк */
  fun disconnect(callback: (Result<Unit>) -> Unit)
  /**
   * Запрос на получение данных о сне
   * Можно также прослушивать стрим sleepData
   */
  fun getSleepData(callback: (Result<List<YuchengSleepEvent?>>) -> Unit)
  /**
   * ТОЛЬКО IOS
   * Возвращает текущий подключенный девайс
   * Если девайс был подключен до этого и не был отключен, то сдк пытается подключиться
   * к девайсу повторно и возвращает его
   */
  fun getCurrentConnectedDevice(callback: (Result<YuchengDevice?>) -> Unit)

  companion object {
    /** The codec used by YuchengHostApi. */
    val codec: MessageCodec<Any?> by lazy {
      YuchengBleApiPigeonCodec()
    }
    /** Sets up an instance of `YuchengHostApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: YuchengHostApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.startScanDevices$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val scanTimeInSecondsArg = args[0] as Double?
            api.startScanDevices(scanTimeInSecondsArg) { result: Result<List<YuchengDevice>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.isDeviceConnected$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val deviceArg = args[0] as YuchengDevice?
            api.isDeviceConnected(deviceArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.connect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val deviceArg = args[0] as YuchengDevice
            api.connect(deviceArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.reconnect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.reconnect{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.disconnect$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.disconnect{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                reply.reply(wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getSleepData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getSleepData{ result: Result<List<YuchengSleepEvent?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getCurrentConnectedDevice$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getCurrentConnectedDevice{ result: Result<YuchengDevice?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}

private class YuchengBleApiPigeonStreamHandler<T>(
    val wrapper: YuchengBleApiPigeonEventChannelWrapper<T>
) : EventChannel.StreamHandler {
  var pigeonSink: PigeonEventSink<T>? = null

  override fun onListen(p0: Any?, sink: EventChannel.EventSink) {
    pigeonSink = PigeonEventSink<T>(sink)
    Log.d("AAAAAAAAAAAAA", "Stream handler onListen; sink = $sink")
    wrapper.onListen(p0, pigeonSink!!)
  }

  override fun onCancel(p0: Any?) {
    Log.d("AAAAAAAAAAAAA", "Stream handler onCancel")
    pigeonSink = null
    wrapper.onCancel(p0)
  }
}

interface YuchengBleApiPigeonEventChannelWrapper<T> {
  open fun onListen(p0: Any?, sink: PigeonEventSink<T>) {}

  open fun onCancel(p0: Any?) {}
}

class PigeonEventSink<T>(private val sink: EventChannel.EventSink) {
  fun success(value: T) {
    sink.success(value)
  }

  fun error(errorCode: String, errorMessage: String?, errorDetails: Any?) {
    sink.error(errorCode, errorMessage, errorDetails)
  }

  fun endOfStream() {
    sink.endOfStream()
  }
}
      
abstract class DevicesStreamHandler : YuchengBleApiPigeonEventChannelWrapper<YuchengDeviceEvent> {
  companion object {
    fun register(messenger: BinaryMessenger, streamHandler: DevicesStreamHandler, instanceName: String = "") {
      var channelName: String = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.devices"
      if (instanceName.isNotEmpty()) {
        channelName += ".$instanceName"
      }
      val internalStreamHandler = YuchengBleApiPigeonStreamHandler<YuchengDeviceEvent>(streamHandler)
      EventChannel(messenger, channelName, YuchengBleApiPigeonMethodCodec).setStreamHandler(internalStreamHandler)
    }
  }
}
      
abstract class SleepDataStreamHandler : YuchengBleApiPigeonEventChannelWrapper<YuchengSleepEvent> {
  companion object {
    fun register(messenger: BinaryMessenger, streamHandler: SleepDataStreamHandler, instanceName: String = "") {
      var channelName: String = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.sleepData"
      if (instanceName.isNotEmpty()) {
        channelName += ".$instanceName"
      }
      val internalStreamHandler = YuchengBleApiPigeonStreamHandler<YuchengSleepEvent>(streamHandler)
      EventChannel(messenger, channelName, YuchengBleApiPigeonMethodCodec).setStreamHandler(internalStreamHandler)
    }
  }
}
      
abstract class DeviceStateStreamHandler : YuchengBleApiPigeonEventChannelWrapper<YuchengDeviceStateEvent> {
  companion object {
    fun register(messenger: BinaryMessenger, streamHandler: DeviceStateStreamHandler, instanceName: String = "") {
      var channelName: String = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.deviceState"
      if (instanceName.isNotEmpty()) {
        channelName += ".$instanceName"
      }
      val internalStreamHandler = YuchengBleApiPigeonStreamHandler<YuchengDeviceStateEvent>(streamHandler)
      EventChannel(messenger, channelName, YuchengBleApiPigeonMethodCodec).setStreamHandler(internalStreamHandler)
    }
  }
}
      
