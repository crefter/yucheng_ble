// Autogenerated from Pigeon (v25.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsYuchengBleApi(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsYuchengBleApi(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsYuchengBleApi(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashYuchengBleApi(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashYuchengBleApi(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashYuchengBleApi(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

enum YuchengSleepType: Int {
  case rem = 0
  case deep = 1
  case awake = 2
  case light = 3
  case unknown = 4
}

enum YuchengDeviceState: Int {
  case unknown = 0
  case connected = 1
  case connectedFailed = 2
  case disconnected = 3
  case unavailable = 4
  case readWriteOK = 5
  case timeOut = 6
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceSettings: Hashable {
  var batteryValue: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceSettings? {
    let batteryValue = pigeonVar_list[0] as! Int64

    return YuchengDeviceSettings(
      batteryValue: batteryValue
    )
  }
  func toList() -> [Any?] {
    return [
      batteryValue
    ]
  }
  static func == (lhs: YuchengDeviceSettings, rhs: YuchengDeviceSettings) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepData: Hashable {
  /// Начало сна в мс
  var startTimeStamp: Int64
  /// Конец сна в мс
  var endTimeStamp: Int64
  /// Если равен 0xFFFF, то новый формат в секундах, иначе старый в минутах
  var deepCount: Int64
  var lightCount: Int64
  var awakeCount: Int64
  var deepInSeconds: Int64
  var remInSeconds: Int64
  var lightInSeconds: Int64
  var awakeInSeconds: Int64
  var details: [YuchengSleepDataDetail]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepData? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let endTimeStamp = pigeonVar_list[1] as! Int64
    let deepCount = pigeonVar_list[2] as! Int64
    let lightCount = pigeonVar_list[3] as! Int64
    let awakeCount = pigeonVar_list[4] as! Int64
    let deepInSeconds = pigeonVar_list[5] as! Int64
    let remInSeconds = pigeonVar_list[6] as! Int64
    let lightInSeconds = pigeonVar_list[7] as! Int64
    let awakeInSeconds = pigeonVar_list[8] as! Int64
    let details = pigeonVar_list[9] as! [YuchengSleepDataDetail]

    return YuchengSleepData(
      startTimeStamp: startTimeStamp,
      endTimeStamp: endTimeStamp,
      deepCount: deepCount,
      lightCount: lightCount,
      awakeCount: awakeCount,
      deepInSeconds: deepInSeconds,
      remInSeconds: remInSeconds,
      lightInSeconds: lightInSeconds,
      awakeInSeconds: awakeInSeconds,
      details: details
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      endTimeStamp,
      deepCount,
      lightCount,
      awakeCount,
      deepInSeconds,
      remInSeconds,
      lightInSeconds,
      awakeInSeconds,
      details,
    ]
  }
  static func == (lhs: YuchengSleepData, rhs: YuchengSleepData) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengHealthData: Hashable {
  var heartValue: Int64
  var hrvValue: Int64
  var cvrrValue: Int64
  var OOValue: Int64
  var stepValue: Int64
  var DBPValue: Int64
  var tempIntValue: Int64
  var tempFloatValue: Int64
  var startTimestamp: Int64
  var SBPValue: Int64
  var respiratoryRateValue: Int64
  var bodyFatIntValue: Int64
  var bodyFatFloatValue: Int64
  var bloodSugarValue: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengHealthData? {
    let heartValue = pigeonVar_list[0] as! Int64
    let hrvValue = pigeonVar_list[1] as! Int64
    let cvrrValue = pigeonVar_list[2] as! Int64
    let OOValue = pigeonVar_list[3] as! Int64
    let stepValue = pigeonVar_list[4] as! Int64
    let DBPValue = pigeonVar_list[5] as! Int64
    let tempIntValue = pigeonVar_list[6] as! Int64
    let tempFloatValue = pigeonVar_list[7] as! Int64
    let startTimestamp = pigeonVar_list[8] as! Int64
    let SBPValue = pigeonVar_list[9] as! Int64
    let respiratoryRateValue = pigeonVar_list[10] as! Int64
    let bodyFatIntValue = pigeonVar_list[11] as! Int64
    let bodyFatFloatValue = pigeonVar_list[12] as! Int64
    let bloodSugarValue = pigeonVar_list[13] as! Int64

    return YuchengHealthData(
      heartValue: heartValue,
      hrvValue: hrvValue,
      cvrrValue: cvrrValue,
      OOValue: OOValue,
      stepValue: stepValue,
      DBPValue: DBPValue,
      tempIntValue: tempIntValue,
      tempFloatValue: tempFloatValue,
      startTimestamp: startTimestamp,
      SBPValue: SBPValue,
      respiratoryRateValue: respiratoryRateValue,
      bodyFatIntValue: bodyFatIntValue,
      bodyFatFloatValue: bodyFatFloatValue,
      bloodSugarValue: bloodSugarValue
    )
  }
  func toList() -> [Any?] {
    return [
      heartValue,
      hrvValue,
      cvrrValue,
      OOValue,
      stepValue,
      DBPValue,
      tempIntValue,
      tempFloatValue,
      startTimestamp,
      SBPValue,
      respiratoryRateValue,
      bodyFatIntValue,
      bodyFatFloatValue,
      bloodSugarValue,
    ]
  }
  static func == (lhs: YuchengHealthData, rhs: YuchengHealthData) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepHealthData: Hashable {
  var sleepData: [YuchengSleepData]
  var healthData: [YuchengHealthData]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepHealthData? {
    let sleepData = pigeonVar_list[0] as! [YuchengSleepData]
    let healthData = pigeonVar_list[1] as! [YuchengHealthData]

    return YuchengSleepHealthData(
      sleepData: sleepData,
      healthData: healthData
    )
  }
  func toList() -> [Any?] {
    return [
      sleepData,
      healthData,
    ]
  }
  static func == (lhs: YuchengSleepHealthData, rhs: YuchengSleepHealthData) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengSleepEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepTimeOutEvent: YuchengSleepEvent {
  var isTimeout: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepTimeOutEvent? {
    let isTimeout = pigeonVar_list[0] as! Bool

    return YuchengSleepTimeOutEvent(
      isTimeout: isTimeout
    )
  }
  func toList() -> [Any?] {
    return [
      isTimeout
    ]
  }
  static func == (lhs: YuchengSleepTimeOutEvent, rhs: YuchengSleepTimeOutEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataEvent: YuchengSleepEvent {
  var sleepData: YuchengSleepData


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataEvent? {
    let sleepData = pigeonVar_list[0] as! YuchengSleepData

    return YuchengSleepDataEvent(
      sleepData: sleepData
    )
  }
  func toList() -> [Any?] {
    return [
      sleepData
    ]
  }
  static func == (lhs: YuchengSleepDataEvent, rhs: YuchengSleepDataEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataDetail: Hashable {
  /// Начало в мс
  var startTimeStamp: Int64
  /// Длительность в мс
  var duration: Int64
  /// Тип сна
  var type: YuchengSleepType


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataDetail? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let duration = pigeonVar_list[1] as! Int64
    let type = pigeonVar_list[2] as! YuchengSleepType

    return YuchengSleepDataDetail(
      startTimeStamp: startTimeStamp,
      duration: duration,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      duration,
      type,
    ]
  }
  static func == (lhs: YuchengSleepDataDetail, rhs: YuchengSleepDataDetail) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepErrorEvent: YuchengSleepEvent {
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepErrorEvent? {
    let error = pigeonVar_list[0] as! String

    return YuchengSleepErrorEvent(
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      error
    ]
  }
  static func == (lhs: YuchengSleepErrorEvent, rhs: YuchengSleepErrorEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengDeviceStateEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceStateTimeOutEvent: YuchengDeviceStateEvent {
  var isTimeout: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceStateTimeOutEvent? {
    let isTimeout = pigeonVar_list[0] as! Bool

    return YuchengDeviceStateTimeOutEvent(
      isTimeout: isTimeout
    )
  }
  func toList() -> [Any?] {
    return [
      isTimeout
    ]
  }
  static func == (lhs: YuchengDeviceStateTimeOutEvent, rhs: YuchengDeviceStateTimeOutEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceStateDataEvent: YuchengDeviceStateEvent {
  var state: YuchengDeviceState


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceStateDataEvent? {
    let state = pigeonVar_list[0] as! YuchengDeviceState

    return YuchengDeviceStateDataEvent(
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      state
    ]
  }
  static func == (lhs: YuchengDeviceStateDataEvent, rhs: YuchengDeviceStateDataEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceStateErrorEvent: YuchengDeviceStateEvent {
  var state: YuchengDeviceState
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceStateErrorEvent? {
    let state = pigeonVar_list[0] as! YuchengDeviceState
    let error = pigeonVar_list[1] as! String

    return YuchengDeviceStateErrorEvent(
      state: state,
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      state,
      error,
    ]
  }
  static func == (lhs: YuchengDeviceStateErrorEvent, rhs: YuchengDeviceStateErrorEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDevice: Hashable {
  var index: Int64
  var deviceName: String
  /// Android - тут mac address для подключения
  /// IOS - uuid девайса
  var uuid: String
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isReconnected: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDevice? {
    let index = pigeonVar_list[0] as! Int64
    let deviceName = pigeonVar_list[1] as! String
    let uuid = pigeonVar_list[2] as! String
    let isReconnected = pigeonVar_list[3] as! Bool

    return YuchengDevice(
      index: index,
      deviceName: deviceName,
      uuid: uuid,
      isReconnected: isReconnected
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      deviceName,
      uuid,
      isReconnected,
    ]
  }
  static func == (lhs: YuchengDevice, rhs: YuchengDevice) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengDeviceEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceTimeOutEvent: YuchengDeviceEvent {
  var isTimeout: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceTimeOutEvent? {
    let isTimeout = pigeonVar_list[0] as! Bool

    return YuchengDeviceTimeOutEvent(
      isTimeout: isTimeout
    )
  }
  func toList() -> [Any?] {
    return [
      isTimeout
    ]
  }
  static func == (lhs: YuchengDeviceTimeOutEvent, rhs: YuchengDeviceTimeOutEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceDataEvent: YuchengDeviceEvent {
  var index: Int64
  /// ДЛЯ ANDROID
  /// Нужен, чтобы подключиться к девайсу
  var mac: String
  /// Только IOS
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isReconnected: Bool
  var deviceName: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceDataEvent? {
    let index = pigeonVar_list[0] as! Int64
    let mac = pigeonVar_list[1] as! String
    let isReconnected = pigeonVar_list[2] as! Bool
    let deviceName = pigeonVar_list[3] as! String

    return YuchengDeviceDataEvent(
      index: index,
      mac: mac,
      isReconnected: isReconnected,
      deviceName: deviceName
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      mac,
      isReconnected,
      deviceName,
    ]
  }
  static func == (lhs: YuchengDeviceDataEvent, rhs: YuchengDeviceDataEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceCompleteEvent: YuchengDeviceEvent {
  var completed: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceCompleteEvent? {
    let completed = pigeonVar_list[0] as! Bool

    return YuchengDeviceCompleteEvent(
      completed: completed
    )
  }
  func toList() -> [Any?] {
    return [
      completed
    ]
  }
  static func == (lhs: YuchengDeviceCompleteEvent, rhs: YuchengDeviceCompleteEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengHealthEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengHealthDataEvent: YuchengHealthEvent {
  var healthData: YuchengHealthData


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengHealthDataEvent? {
    let healthData = pigeonVar_list[0] as! YuchengHealthData

    return YuchengHealthDataEvent(
      healthData: healthData
    )
  }
  func toList() -> [Any?] {
    return [
      healthData
    ]
  }
  static func == (lhs: YuchengHealthDataEvent, rhs: YuchengHealthDataEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengHealthErrorEvent: YuchengHealthEvent {
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengHealthErrorEvent? {
    let error = pigeonVar_list[0] as! String

    return YuchengHealthErrorEvent(
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      error
    ]
  }
  static func == (lhs: YuchengHealthErrorEvent, rhs: YuchengHealthErrorEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengHealthTimeOutEvent: YuchengHealthEvent {
  var isTimeout: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengHealthTimeOutEvent? {
    let isTimeout = pigeonVar_list[0] as! Bool

    return YuchengHealthTimeOutEvent(
      isTimeout: isTimeout
    )
  }
  func toList() -> [Any?] {
    return [
      isTimeout
    ]
  }
  static func == (lhs: YuchengHealthTimeOutEvent, rhs: YuchengHealthTimeOutEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengSleepHealthEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepHealthDataEvent: YuchengSleepHealthEvent {
  var data: YuchengSleepHealthData


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepHealthDataEvent? {
    let data = pigeonVar_list[0] as! YuchengSleepHealthData

    return YuchengSleepHealthDataEvent(
      data: data
    )
  }
  func toList() -> [Any?] {
    return [
      data
    ]
  }
  static func == (lhs: YuchengSleepHealthDataEvent, rhs: YuchengSleepHealthDataEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepHealthErrorEvent: YuchengSleepHealthEvent {
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepHealthErrorEvent? {
    let error = pigeonVar_list[0] as! String

    return YuchengSleepHealthErrorEvent(
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      error
    ]
  }
  static func == (lhs: YuchengSleepHealthErrorEvent, rhs: YuchengSleepHealthErrorEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepHealthTimeOutEvent: YuchengSleepHealthEvent {
  var isTimeout: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepHealthTimeOutEvent? {
    let isTimeout = pigeonVar_list[0] as! Bool

    return YuchengSleepHealthTimeOutEvent(
      isTimeout: isTimeout
    )
  }
  func toList() -> [Any?] {
    return [
      isTimeout
    ]
  }
  static func == (lhs: YuchengSleepHealthTimeOutEvent, rhs: YuchengSleepHealthTimeOutEvent) -> Bool {
    return deepEqualsYuchengBleApi(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashYuchengBleApi(value: toList(), hasher: &hasher)
  }
}

private class YuchengBleApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengSleepType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengDeviceState(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return YuchengDeviceSettings.fromList(self.readValue() as! [Any?])
    case 132:
      return YuchengSleepData.fromList(self.readValue() as! [Any?])
    case 133:
      return YuchengHealthData.fromList(self.readValue() as! [Any?])
    case 134:
      return YuchengSleepHealthData.fromList(self.readValue() as! [Any?])
    case 135:
      return YuchengSleepTimeOutEvent.fromList(self.readValue() as! [Any?])
    case 136:
      return YuchengSleepDataEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return YuchengSleepDataDetail.fromList(self.readValue() as! [Any?])
    case 138:
      return YuchengSleepErrorEvent.fromList(self.readValue() as! [Any?])
    case 139:
      return YuchengDeviceStateTimeOutEvent.fromList(self.readValue() as! [Any?])
    case 140:
      return YuchengDeviceStateDataEvent.fromList(self.readValue() as! [Any?])
    case 141:
      return YuchengDeviceStateErrorEvent.fromList(self.readValue() as! [Any?])
    case 142:
      return YuchengDevice.fromList(self.readValue() as! [Any?])
    case 143:
      return YuchengDeviceTimeOutEvent.fromList(self.readValue() as! [Any?])
    case 144:
      return YuchengDeviceDataEvent.fromList(self.readValue() as! [Any?])
    case 145:
      return YuchengDeviceCompleteEvent.fromList(self.readValue() as! [Any?])
    case 146:
      return YuchengHealthDataEvent.fromList(self.readValue() as! [Any?])
    case 147:
      return YuchengHealthErrorEvent.fromList(self.readValue() as! [Any?])
    case 148:
      return YuchengHealthTimeOutEvent.fromList(self.readValue() as! [Any?])
    case 149:
      return YuchengSleepHealthDataEvent.fromList(self.readValue() as! [Any?])
    case 150:
      return YuchengSleepHealthErrorEvent.fromList(self.readValue() as! [Any?])
    case 151:
      return YuchengSleepHealthTimeOutEvent.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class YuchengBleApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? YuchengSleepType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengDeviceState {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengDeviceSettings {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepData {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengHealthData {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepHealthData {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepTimeOutEvent {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataDetail {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepErrorEvent {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceStateTimeOutEvent {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceStateDataEvent {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceStateErrorEvent {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDevice {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceTimeOutEvent {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceDataEvent {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceCompleteEvent {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengHealthDataEvent {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengHealthErrorEvent {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengHealthTimeOutEvent {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepHealthDataEvent {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepHealthErrorEvent {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepHealthTimeOutEvent {
      super.writeByte(151)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class YuchengBleApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return YuchengBleApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return YuchengBleApiPigeonCodecWriter(data: data)
  }
}

class YuchengBleApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = YuchengBleApiPigeonCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter())
}

var yuchengBleApiPigeonMethodCodec = FlutterStandardMethodCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter());


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol YuchengHostApi {
  /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды для ios и 10 для андройд)
  /// Прослушивать стрим devices
  ///
  /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
  /// на bluetooth
  func startScanDevices(scanTimeInSeconds: Double?, completion: @escaping (Result<[YuchengDevice], Error>) -> Void)
  /// Работает для IOS, для андройд будет просто проверка, подключен ли какой-либо девайс к сдк
  /// [device] - девайс, который нужно проверить
  /// Проверяет, подключен ли данный девайс
  func isDeviceConnected(device: YuchengDevice?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Подключить девайс к сдк
  func connect(device: YuchengDevice, completion: @escaping (Result<Bool, Error>) -> Void)
  func reconnect(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Отключить девайс от сдк
  func disconnect(completion: @escaping (Result<Void, Error>) -> Void)
  /// Запрос на получение данных о сне
  /// Можно также прослушивать стрим sleepData
  func getSleepData(startTimestamp: Int64?, endTimestamp: Int64?, completion: @escaping (Result<[YuchengSleepData], Error>) -> Void)
  /// Возвращает текущий подключенный девайс
  func getCurrentConnectedDevice(completion: @escaping (Result<YuchengDevice?, Error>) -> Void)
  func getHealthData(startTimestamp: Int64?, endTimestamp: Int64?, completion: @escaping (Result<[YuchengHealthData], Error>) -> Void)
  func getSleepHealthData(startTimestamp: Int64?, endTimestamp: Int64?, completion: @escaping (Result<YuchengSleepHealthData, Error>) -> Void)
  func getDeviceSettings(completion: @escaping (Result<YuchengDeviceSettings?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class YuchengHostApiSetup {
  static var codec: FlutterStandardMessageCodec { YuchengBleApiPigeonCodec.shared }
  /// Sets up an instance of `YuchengHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: YuchengHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды для ios и 10 для андройд)
    /// Прослушивать стрим devices
    ///
    /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
    /// на bluetooth
    let startScanDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.startScanDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startScanDevicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let scanTimeInSecondsArg: Double? = nilOrValue(args[0])
        api.startScanDevices(scanTimeInSeconds: scanTimeInSecondsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startScanDevicesChannel.setMessageHandler(nil)
    }
    /// Работает для IOS, для андройд будет просто проверка, подключен ли какой-либо девайс к сдк
    /// [device] - девайс, который нужно проверить
    /// Проверяет, подключен ли данный девайс
    let isDeviceConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.isDeviceConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isDeviceConnectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg: YuchengDevice? = nilOrValue(args[0])
        api.isDeviceConnected(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isDeviceConnectedChannel.setMessageHandler(nil)
    }
    /// Подключить девайс к сдк
    let connectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.connect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      connectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg = args[0] as! YuchengDevice
        api.connect(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      connectChannel.setMessageHandler(nil)
    }
    let reconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.reconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reconnectChannel.setMessageHandler { _, reply in
        api.reconnect { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      reconnectChannel.setMessageHandler(nil)
    }
    /// Отключить девайс от сдк
    let disconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.disconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disconnectChannel.setMessageHandler { _, reply in
        api.disconnect { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disconnectChannel.setMessageHandler(nil)
    }
    /// Запрос на получение данных о сне
    /// Можно также прослушивать стрим sleepData
    let getSleepDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getSleepData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSleepDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let startTimestampArg: Int64? = nilOrValue(args[0])
        let endTimestampArg: Int64? = nilOrValue(args[1])
        api.getSleepData(startTimestamp: startTimestampArg, endTimestamp: endTimestampArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSleepDataChannel.setMessageHandler(nil)
    }
    /// Возвращает текущий подключенный девайс
    let getCurrentConnectedDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getCurrentConnectedDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentConnectedDeviceChannel.setMessageHandler { _, reply in
        api.getCurrentConnectedDevice { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentConnectedDeviceChannel.setMessageHandler(nil)
    }
    let getHealthDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getHealthData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getHealthDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let startTimestampArg: Int64? = nilOrValue(args[0])
        let endTimestampArg: Int64? = nilOrValue(args[1])
        api.getHealthData(startTimestamp: startTimestampArg, endTimestamp: endTimestampArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getHealthDataChannel.setMessageHandler(nil)
    }
    let getSleepHealthDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getSleepHealthData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSleepHealthDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let startTimestampArg: Int64? = nilOrValue(args[0])
        let endTimestampArg: Int64? = nilOrValue(args[1])
        api.getSleepHealthData(startTimestamp: startTimestampArg, endTimestamp: endTimestampArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSleepHealthDataChannel.setMessageHandler(nil)
    }
    let getDeviceSettingsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getDeviceSettings\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDeviceSettingsChannel.setMessageHandler { _, reply in
        api.getDeviceSettings { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDeviceSettingsChannel.setMessageHandler(nil)
    }
  }
}

private class PigeonStreamHandler<ReturnType>: NSObject, FlutterStreamHandler {
  private let wrapper: PigeonEventChannelWrapper<ReturnType>
  private var pigeonSink: PigeonEventSink<ReturnType>? = nil

  init(wrapper: PigeonEventChannelWrapper<ReturnType>) {
    self.wrapper = wrapper
  }

  func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink)
    -> FlutterError?
  {
    pigeonSink = PigeonEventSink<ReturnType>(events)
    wrapper.onListen(withArguments: arguments, sink: pigeonSink!)
    return nil
  }

  func onCancel(withArguments arguments: Any?) -> FlutterError? {
    pigeonSink = nil
    wrapper.onCancel(withArguments: arguments)
    return nil
  }
}

class PigeonEventChannelWrapper<ReturnType> {
  func onListen(withArguments arguments: Any?, sink: PigeonEventSink<ReturnType>) {}
  func onCancel(withArguments arguments: Any?) {}
}

class PigeonEventSink<ReturnType> {
  private let sink: FlutterEventSink

  init(_ sink: @escaping FlutterEventSink) {
    self.sink = sink
  }

  func success(_ value: ReturnType) {
    sink(value)
  }

  func error(code: String, message: String?, details: Any?) {
    sink(FlutterError(code: code, message: message, details: details))
  }

  func endOfStream() {
    sink(FlutterEndOfEventStream)
  }

}

class DevicesStreamHandler: PigeonEventChannelWrapper<YuchengDeviceEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DevicesStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.devices"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengDeviceEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class SleepDataStreamHandler: PigeonEventChannelWrapper<YuchengSleepEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: SleepDataStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.sleepData"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengSleepEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class DeviceStateStreamHandler: PigeonEventChannelWrapper<YuchengDeviceStateEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DeviceStateStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.deviceState"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengDeviceStateEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class HealthDataStreamHandler: PigeonEventChannelWrapper<YuchengHealthEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: HealthDataStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.healthData"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengHealthEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class SleepHealthDataStreamHandler: PigeonEventChannelWrapper<YuchengSleepHealthEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: SleepHealthDataStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.sleepHealthData"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengSleepHealthEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
