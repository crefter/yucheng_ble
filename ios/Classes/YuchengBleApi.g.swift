// Autogenerated from Pigeon (v25.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum YuchengSleepType: Int {
  case rem = 0
  case deep = 1
  case awake = 2
  case light = 3
  case unknown = 4
}

enum YuchengProductState: Int {
  case unknown = 0
  case connected = 1
  case connectedFailed = 2
  case disconnected = 3
  case unavailable = 4
  case timeOut = 5
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengSleepEvent {

}

/// Старый формат в минутах
///
/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataMinutes {
  var deepSleepMinutes: Int64
  var remSleepMinutes: Int64
  var lightSleepMinutes: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataMinutes? {
    let deepSleepMinutes = pigeonVar_list[0] as! Int64
    let remSleepMinutes = pigeonVar_list[1] as! Int64
    let lightSleepMinutes = pigeonVar_list[2] as! Int64

    return YuchengSleepDataMinutes(
      deepSleepMinutes: deepSleepMinutes,
      remSleepMinutes: remSleepMinutes,
      lightSleepMinutes: lightSleepMinutes
    )
  }
  func toList() -> [Any?] {
    return [
      deepSleepMinutes,
      remSleepMinutes,
      lightSleepMinutes,
    ]
  }
}

/// Если deepSleepCount == 0xFFFF, то новый формат в секундах
///
/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataSeconds {
  var deepSleepSeconds: Int64
  var remSleepSeconds: Int64
  var lightSleepSeconds: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataSeconds? {
    let deepSleepSeconds = pigeonVar_list[0] as! Int64
    let remSleepSeconds = pigeonVar_list[1] as! Int64
    let lightSleepSeconds = pigeonVar_list[2] as! Int64

    return YuchengSleepDataSeconds(
      deepSleepSeconds: deepSleepSeconds,
      remSleepSeconds: remSleepSeconds,
      lightSleepSeconds: lightSleepSeconds
    )
  }
  func toList() -> [Any?] {
    return [
      deepSleepSeconds,
      remSleepSeconds,
      lightSleepSeconds,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataEvent: YuchengSleepEvent {
  /// Начало сна в мс
  var startTimeStamp: Int64
  /// Конец сна в мс
  var endTimeStamp: Int64
  /// Если равен 0xFFFF, то новый формат в секундах, иначе старый в минутах
  var deepSleepCount: Int64
  var lightSleepCount: Int64
  /// Старый формат, если [deepSleepCount] != 0xFFFF
  var minutes: YuchengSleepDataMinutes? = nil
  /// Новый формат, если [deepSleepCount] == 0xFFFF
  var seconds: YuchengSleepDataSeconds? = nil
  var details: [YuchengSleepDataDetail]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataEvent? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let endTimeStamp = pigeonVar_list[1] as! Int64
    let deepSleepCount = pigeonVar_list[2] as! Int64
    let lightSleepCount = pigeonVar_list[3] as! Int64
    let minutes: YuchengSleepDataMinutes? = nilOrValue(pigeonVar_list[4])
    let seconds: YuchengSleepDataSeconds? = nilOrValue(pigeonVar_list[5])
    let details = pigeonVar_list[6] as! [YuchengSleepDataDetail]

    return YuchengSleepDataEvent(
      startTimeStamp: startTimeStamp,
      endTimeStamp: endTimeStamp,
      deepSleepCount: deepSleepCount,
      lightSleepCount: lightSleepCount,
      minutes: minutes,
      seconds: seconds,
      details: details
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      endTimeStamp,
      deepSleepCount,
      lightSleepCount,
      minutes,
      seconds,
      details,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataDetail {
  /// Начало в мс
  var startTimeStamp: Int64
  /// Длительность в мс
  var duration: Int64
  /// Тип сна
  var type: YuchengSleepType


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataDetail? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let duration = pigeonVar_list[1] as! Int64
    let type = pigeonVar_list[2] as! YuchengSleepType

    return YuchengSleepDataDetail(
      startTimeStamp: startTimeStamp,
      duration: duration,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      duration,
      type,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepErrorEvent: YuchengSleepEvent {
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepErrorEvent? {
    let error = pigeonVar_list[0] as! String

    return YuchengSleepErrorEvent(
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      error
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengProductStateEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengProductStateDataEvent: YuchengProductStateEvent {
  var state: YuchengProductState


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengProductStateDataEvent? {
    let state = pigeonVar_list[0] as! YuchengProductState

    return YuchengProductStateDataEvent(
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      state
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengProductStateErrorEvent: YuchengProductStateEvent {
  var state: YuchengProductState
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengProductStateErrorEvent? {
    let state = pigeonVar_list[0] as! YuchengProductState
    let error = pigeonVar_list[1] as! String

    return YuchengProductStateErrorEvent(
      state: state,
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      state,
      error,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDevice {
  var index: Int64
  var deviceName: String
  var uuid: String
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isCurrentConnected: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDevice? {
    let index = pigeonVar_list[0] as! Int64
    let deviceName = pigeonVar_list[1] as! String
    let uuid = pigeonVar_list[2] as! String
    let isCurrentConnected = pigeonVar_list[3] as! Bool

    return YuchengDevice(
      index: index,
      deviceName: deviceName,
      uuid: uuid,
      isCurrentConnected: isCurrentConnected
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      deviceName,
      uuid,
      isCurrentConnected,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengDeviceEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceDataEvent: YuchengDeviceEvent {
  var index: Int64
  var uuid: String
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isCurrentConnected: Bool
  var deviceName: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceDataEvent? {
    let index = pigeonVar_list[0] as! Int64
    let uuid = pigeonVar_list[1] as! String
    let isCurrentConnected = pigeonVar_list[2] as! Bool
    let deviceName = pigeonVar_list[3] as! String

    return YuchengDeviceDataEvent(
      index: index,
      uuid: uuid,
      isCurrentConnected: isCurrentConnected,
      deviceName: deviceName
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      uuid,
      isCurrentConnected,
      deviceName,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceCompleteEvent: YuchengDeviceEvent {
  var completed: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceCompleteEvent? {
    let completed = pigeonVar_list[0] as! Bool

    return YuchengDeviceCompleteEvent(
      completed: completed
    )
  }
  func toList() -> [Any?] {
    return [
      completed
    ]
  }
}

private class YuchengBleApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengSleepType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengProductState(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return YuchengSleepDataMinutes.fromList(self.readValue() as! [Any?])
    case 132:
      return YuchengSleepDataSeconds.fromList(self.readValue() as! [Any?])
    case 133:
      return YuchengSleepDataEvent.fromList(self.readValue() as! [Any?])
    case 134:
      return YuchengSleepDataDetail.fromList(self.readValue() as! [Any?])
    case 135:
      return YuchengSleepErrorEvent.fromList(self.readValue() as! [Any?])
    case 136:
      return YuchengProductStateDataEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return YuchengProductStateErrorEvent.fromList(self.readValue() as! [Any?])
    case 138:
      return YuchengDevice.fromList(self.readValue() as! [Any?])
    case 139:
      return YuchengDeviceDataEvent.fromList(self.readValue() as! [Any?])
    case 140:
      return YuchengDeviceCompleteEvent.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class YuchengBleApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? YuchengSleepType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengProductState {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengSleepDataMinutes {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataSeconds {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataEvent {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataDetail {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepErrorEvent {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengProductStateDataEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengProductStateErrorEvent {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDevice {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceDataEvent {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceCompleteEvent {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class YuchengBleApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return YuchengBleApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return YuchengBleApiPigeonCodecWriter(data: data)
  }
}

class YuchengBleApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = YuchengBleApiPigeonCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter())
}

var yuchengBleApiPigeonMethodCodec = FlutterStandardMethodCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter());


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol YuchengHostApi {
  /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды)
  /// Прослушивать стрим devices
  ///
  /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
  /// на bluetooth
  func startScanDevices(scanTimeInSeconds: Double?) throws
  /// [device] - девайс, который нужно проверить
  /// Проверяет, подключен ли данный девайс
  func isDeviceConnected(device: YuchengDevice, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Подключить девайс к сдк
  func connect(device: YuchengDevice?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Отключить девайс от сдк
  func disconnect(completion: @escaping (Result<Void, Error>) -> Void)
  /// Запрос на получение данных о сне
  /// Можно также прослушивать стрим sleepData
  func getSleepData(completion: @escaping (Result<[YuchengSleepDataEvent?], Error>) -> Void)
  /// Возвращает текущий подключенный девайс
  /// Если девайс был подключен до этого и не был отключен, то сдк пытается подключиться
  /// к девайсу повторно и возвращает его
  func getCurrentConnectedDevice(completion: @escaping (Result<YuchengDevice?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class YuchengHostApiSetup {
  static var codec: FlutterStandardMessageCodec { YuchengBleApiPigeonCodec.shared }
  /// Sets up an instance of `YuchengHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: YuchengHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды)
    /// Прослушивать стрим devices
    ///
    /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
    /// на bluetooth
    let startScanDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.startScanDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startScanDevicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let scanTimeInSecondsArg: Double? = nilOrValue(args[0])
        do {
          try api.startScanDevices(scanTimeInSeconds: scanTimeInSecondsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startScanDevicesChannel.setMessageHandler(nil)
    }
    /// [device] - девайс, который нужно проверить
    /// Проверяет, подключен ли данный девайс
    let isDeviceConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.isDeviceConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isDeviceConnectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg = args[0] as! YuchengDevice
        api.isDeviceConnected(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isDeviceConnectedChannel.setMessageHandler(nil)
    }
    /// Подключить девайс к сдк
    let connectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.connect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      connectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg: YuchengDevice? = nilOrValue(args[0])
        api.connect(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      connectChannel.setMessageHandler(nil)
    }
    /// Отключить девайс от сдк
    let disconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.disconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disconnectChannel.setMessageHandler { _, reply in
        api.disconnect { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disconnectChannel.setMessageHandler(nil)
    }
    /// Запрос на получение данных о сне
    /// Можно также прослушивать стрим sleepData
    let getSleepDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getSleepData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSleepDataChannel.setMessageHandler { _, reply in
        api.getSleepData { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSleepDataChannel.setMessageHandler(nil)
    }
    /// Возвращает текущий подключенный девайс
    /// Если девайс был подключен до этого и не был отключен, то сдк пытается подключиться
    /// к девайсу повторно и возвращает его
    let getCurrentConnectedDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getCurrentConnectedDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentConnectedDeviceChannel.setMessageHandler { _, reply in
        api.getCurrentConnectedDevice { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentConnectedDeviceChannel.setMessageHandler(nil)
    }
  }
}

private class PigeonStreamHandler<ReturnType>: NSObject, FlutterStreamHandler {
  private let wrapper: PigeonEventChannelWrapper<ReturnType>
  private var pigeonSink: PigeonEventSink<ReturnType>? = nil

  init(wrapper: PigeonEventChannelWrapper<ReturnType>) {
    self.wrapper = wrapper
  }

  func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink)
    -> FlutterError?
  {
    pigeonSink = PigeonEventSink<ReturnType>(events)
    wrapper.onListen(withArguments: arguments, sink: pigeonSink!)
    return nil
  }

  func onCancel(withArguments arguments: Any?) -> FlutterError? {
    pigeonSink = nil
    wrapper.onCancel(withArguments: arguments)
    return nil
  }
}

class PigeonEventChannelWrapper<ReturnType> {
  func onListen(withArguments arguments: Any?, sink: PigeonEventSink<ReturnType>) {}
  func onCancel(withArguments arguments: Any?) {}
}

class PigeonEventSink<ReturnType> {
  private let sink: FlutterEventSink

  init(_ sink: @escaping FlutterEventSink) {
    self.sink = sink
  }

  func success(_ value: ReturnType) {
    sink(value)
  }

  func error(code: String, message: String?, details: Any?) {
    sink(FlutterError(code: code, message: message, details: details))
  }

  func endOfStream() {
    sink(FlutterEndOfEventStream)
  }

}

class DevicesStreamHandler: PigeonEventChannelWrapper<YuchengDeviceEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DevicesStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.devices"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengDeviceEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class SleepDataStreamHandler: PigeonEventChannelWrapper<YuchengSleepDataEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: SleepDataStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.sleepData"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengSleepDataEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class DeviceStateStreamHandler: PigeonEventChannelWrapper<YuchengProductStateEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DeviceStateStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.deviceState"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengProductStateEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
