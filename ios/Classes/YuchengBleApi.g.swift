// Autogenerated from Pigeon (v25.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum YuchengSleepType: Int {
  case rem = 0
  case deep = 1
  case awake = 2
  case light = 3
  case unknown = 4
}

enum YuchengProductState: Int {
  case unknown = 0
  case connected = 1
  case connectedFailed = 2
  case disconnected = 3
  case unavailable = 4
  case readWriteOK = 5
  case timeOut = 6
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengSleepEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataEvent: YuchengSleepEvent {
  /// Начало сна в мс
  var startTimeStamp: Int64
  /// Конец сна в мс
  var endTimeStamp: Int64
  /// Если равен 0xFFFF, то новый формат в секундах, иначе старый в минутах
  var deepCount: Int64
  var lightCount: Int64
  var awakeCount: Int64
  var deepInSeconds: Int64
  var remInSeconds: Int64
  var lightInSeconds: Int64
  var awakeInSeconds: Int64
  var details: [YuchengSleepDataDetail]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataEvent? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let endTimeStamp = pigeonVar_list[1] as! Int64
    let deepCount = pigeonVar_list[2] as! Int64
    let lightCount = pigeonVar_list[3] as! Int64
    let awakeCount = pigeonVar_list[4] as! Int64
    let deepInSeconds = pigeonVar_list[5] as! Int64
    let remInSeconds = pigeonVar_list[6] as! Int64
    let lightInSeconds = pigeonVar_list[7] as! Int64
    let awakeInSeconds = pigeonVar_list[8] as! Int64
    let details = pigeonVar_list[9] as! [YuchengSleepDataDetail]

    return YuchengSleepDataEvent(
      startTimeStamp: startTimeStamp,
      endTimeStamp: endTimeStamp,
      deepCount: deepCount,
      lightCount: lightCount,
      awakeCount: awakeCount,
      deepInSeconds: deepInSeconds,
      remInSeconds: remInSeconds,
      lightInSeconds: lightInSeconds,
      awakeInSeconds: awakeInSeconds,
      details: details
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      endTimeStamp,
      deepCount,
      lightCount,
      awakeCount,
      deepInSeconds,
      remInSeconds,
      lightInSeconds,
      awakeInSeconds,
      details,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepDataDetail {
  /// Начало в мс
  var startTimeStamp: Int64
  /// Длительность в мс
  var duration: Int64
  /// Тип сна
  var type: YuchengSleepType


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepDataDetail? {
    let startTimeStamp = pigeonVar_list[0] as! Int64
    let duration = pigeonVar_list[1] as! Int64
    let type = pigeonVar_list[2] as! YuchengSleepType

    return YuchengSleepDataDetail(
      startTimeStamp: startTimeStamp,
      duration: duration,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      startTimeStamp,
      duration,
      type,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengSleepErrorEvent: YuchengSleepEvent {
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengSleepErrorEvent? {
    let error = pigeonVar_list[0] as! String

    return YuchengSleepErrorEvent(
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      error
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengDeviceStateEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceStateDataEvent: YuchengDeviceStateEvent {
  var state: YuchengProductState


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceStateDataEvent? {
    let state = pigeonVar_list[0] as! YuchengProductState

    return YuchengDeviceStateDataEvent(
      state: state
    )
  }
  func toList() -> [Any?] {
    return [
      state
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceStateErrorEvent: YuchengDeviceStateEvent {
  var state: YuchengProductState
  var error: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceStateErrorEvent? {
    let state = pigeonVar_list[0] as! YuchengProductState
    let error = pigeonVar_list[1] as! String

    return YuchengDeviceStateErrorEvent(
      state: state,
      error: error
    )
  }
  func toList() -> [Any?] {
    return [
      state,
      error,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDevice {
  var index: Int64
  var deviceName: String
  /// Android - тут mac address для подключения
  /// IOS - uuid девайса
  var uuid: String
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isCurrentConnected: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDevice? {
    let index = pigeonVar_list[0] as! Int64
    let deviceName = pigeonVar_list[1] as! String
    let uuid = pigeonVar_list[2] as! String
    let isCurrentConnected = pigeonVar_list[3] as! Bool

    return YuchengDevice(
      index: index,
      deviceName: deviceName,
      uuid: uuid,
      isCurrentConnected: isCurrentConnected
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      deviceName,
      uuid,
      isCurrentConnected,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol YuchengDeviceEvent {

}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceDataEvent: YuchengDeviceEvent {
  var index: Int64
  /// ДЛЯ ANDROID
  /// Нужен, чтобы подключиться к девайсу
  /// ДЛЯ IOS
  /// Uuid девайса
  var mac: String
  /// Только IOS
  /// true - уже изначально подключен
  /// false - не был подключен изначально, нужно подключить
  var isCurrentConnected: Bool? = nil
  var deviceName: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceDataEvent? {
    let index = pigeonVar_list[0] as! Int64
    let mac = pigeonVar_list[1] as! String
    let isCurrentConnected: Bool? = nilOrValue(pigeonVar_list[2])
    let deviceName = pigeonVar_list[3] as! String

    return YuchengDeviceDataEvent(
      index: index,
      mac: mac,
      isCurrentConnected: isCurrentConnected,
      deviceName: deviceName
    )
  }
  func toList() -> [Any?] {
    return [
      index,
      mac,
      isCurrentConnected,
      deviceName,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct YuchengDeviceCompleteEvent: YuchengDeviceEvent {
  var completed: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> YuchengDeviceCompleteEvent? {
    let completed = pigeonVar_list[0] as! Bool

    return YuchengDeviceCompleteEvent(
      completed: completed
    )
  }
  func toList() -> [Any?] {
    return [
      completed
    ]
  }
}

private class YuchengBleApiPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengSleepType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return YuchengProductState(rawValue: enumResultAsInt)
      }
      return nil
    case 131:
      return YuchengSleepDataEvent.fromList(self.readValue() as! [Any?])
    case 132:
      return YuchengSleepDataDetail.fromList(self.readValue() as! [Any?])
    case 133:
      return YuchengSleepErrorEvent.fromList(self.readValue() as! [Any?])
    case 134:
      return YuchengDeviceStateDataEvent.fromList(self.readValue() as! [Any?])
    case 135:
      return YuchengDeviceStateErrorEvent.fromList(self.readValue() as! [Any?])
    case 136:
      return YuchengDevice.fromList(self.readValue() as! [Any?])
    case 137:
      return YuchengDeviceDataEvent.fromList(self.readValue() as! [Any?])
    case 138:
      return YuchengDeviceCompleteEvent.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class YuchengBleApiPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? YuchengSleepType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengProductState {
      super.writeByte(130)
      super.writeValue(value.rawValue)
    } else if let value = value as? YuchengSleepDataEvent {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepDataDetail {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengSleepErrorEvent {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceStateDataEvent {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceStateErrorEvent {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDevice {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceDataEvent {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? YuchengDeviceCompleteEvent {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class YuchengBleApiPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return YuchengBleApiPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return YuchengBleApiPigeonCodecWriter(data: data)
  }
}

class YuchengBleApiPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = YuchengBleApiPigeonCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter())
}

var yuchengBleApiPigeonMethodCodec = FlutterStandardMethodCodec(readerWriter: YuchengBleApiPigeonCodecReaderWriter());


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol YuchengHostApi {
  /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды для ios и 10 для андройд)
  /// Прослушивать стрим devices
  ///
  /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
  /// на bluetooth
  func startScanDevices(scanTimeInSeconds: Double?, completion: @escaping (Result<[YuchengDevice], Error>) -> Void)
  /// Работает для IOS, для андройд будет просто проверка, подключен ли какой-либо девайс к сдк
  /// [device] - девайс, который нужно проверить
  /// Проверяет, подключен ли данный девайс
  func isDeviceConnected(device: YuchengDevice?, completion: @escaping (Result<Bool, Error>) -> Void)
  /// Подключить девайс к сдк
  func connect(device: YuchengDevice, completion: @escaping (Result<Bool, Error>) -> Void)
  func reconnect(completion: @escaping (Result<Bool, Error>) -> Void)
  /// Отключить девайс от сдк
  func disconnect(completion: @escaping (Result<Void, Error>) -> Void)
  /// Запрос на получение данных о сне
  /// Можно также прослушивать стрим sleepData
  func getSleepData(completion: @escaping (Result<[YuchengSleepEvent?], Error>) -> Void)
  /// ТОЛЬКО IOS
  /// Возвращает текущий подключенный девайс
  /// Если девайс был подключен до этого и не был отключен, то сдк пытается подключиться
  /// к девайсу повторно и возвращает его
  func getCurrentConnectedDevice(completion: @escaping (Result<YuchengDevice?, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class YuchengHostApiSetup {
  static var codec: FlutterStandardMessageCodec { YuchengBleApiPigeonCodec.shared }
  /// Sets up an instance of `YuchengHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: YuchengHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// [scanTimeInMs] - сколько по времени сканировать (по умолчанию 3 секунды для ios и 10 для андройд)
    /// Прослушивать стрим devices
    ///
    /// Перед сканированием нужно проверить, включен ли bluetooth и запросить разрешения
    /// на bluetooth
    let startScanDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.startScanDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startScanDevicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let scanTimeInSecondsArg: Double? = nilOrValue(args[0])
        api.startScanDevices(scanTimeInSeconds: scanTimeInSecondsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startScanDevicesChannel.setMessageHandler(nil)
    }
    /// Работает для IOS, для андройд будет просто проверка, подключен ли какой-либо девайс к сдк
    /// [device] - девайс, который нужно проверить
    /// Проверяет, подключен ли данный девайс
    let isDeviceConnectedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.isDeviceConnected\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isDeviceConnectedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg: YuchengDevice? = nilOrValue(args[0])
        api.isDeviceConnected(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isDeviceConnectedChannel.setMessageHandler(nil)
    }
    /// Подключить девайс к сдк
    let connectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.connect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      connectChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceArg = args[0] as! YuchengDevice
        api.connect(device: deviceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      connectChannel.setMessageHandler(nil)
    }
    let reconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.reconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      reconnectChannel.setMessageHandler { _, reply in
        api.reconnect { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      reconnectChannel.setMessageHandler(nil)
    }
    /// Отключить девайс от сдк
    let disconnectChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.disconnect\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disconnectChannel.setMessageHandler { _, reply in
        api.disconnect { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disconnectChannel.setMessageHandler(nil)
    }
    /// Запрос на получение данных о сне
    /// Можно также прослушивать стрим sleepData
    let getSleepDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getSleepData\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSleepDataChannel.setMessageHandler { _, reply in
        api.getSleepData { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSleepDataChannel.setMessageHandler(nil)
    }
    /// ТОЛЬКО IOS
    /// Возвращает текущий подключенный девайс
    /// Если девайс был подключен до этого и не был отключен, то сдк пытается подключиться
    /// к девайсу повторно и возвращает его
    let getCurrentConnectedDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.yucheng_ble.YuchengHostApi.getCurrentConnectedDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentConnectedDeviceChannel.setMessageHandler { _, reply in
        api.getCurrentConnectedDevice { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentConnectedDeviceChannel.setMessageHandler(nil)
    }
  }
}

private class PigeonStreamHandler<ReturnType>: NSObject, FlutterStreamHandler {
  private let wrapper: PigeonEventChannelWrapper<ReturnType>
  private var pigeonSink: PigeonEventSink<ReturnType>? = nil

  init(wrapper: PigeonEventChannelWrapper<ReturnType>) {
    self.wrapper = wrapper
  }

  func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink)
    -> FlutterError?
  {
    pigeonSink = PigeonEventSink<ReturnType>(events)
    print("Pigeon onListen")
    wrapper.onListen(withArguments: arguments, sink: pigeonSink!)
    return nil
  }

  func onCancel(withArguments arguments: Any?) -> FlutterError? {
    pigeonSink = nil
    print("Pigeon onCancel")
    wrapper.onCancel(withArguments: arguments)
    return nil
  }
}

class PigeonEventChannelWrapper<ReturnType> {
  func onListen(withArguments arguments: Any?, sink: PigeonEventSink<ReturnType>) {}
  func onCancel(withArguments arguments: Any?) {}
}

class PigeonEventSink<ReturnType> {
  private let sink: FlutterEventSink

  init(_ sink: @escaping FlutterEventSink) {
    self.sink = sink
  }

  func success(_ value: ReturnType) {
    sink(value)
  }

  func error(code: String, message: String?, details: Any?) {
    sink(FlutterError(code: code, message: message, details: details))
  }

  func endOfStream() {
    sink(FlutterEndOfEventStream)
  }

}

class DevicesStreamHandler: PigeonEventChannelWrapper<YuchengDeviceEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DevicesStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.devices"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengDeviceEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class SleepDataStreamHandler: PigeonEventChannelWrapper<YuchengSleepEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: SleepDataStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.sleepData"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengSleepEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
class DeviceStateStreamHandler: PigeonEventChannelWrapper<YuchengDeviceStateEvent> {
  static func register(with messenger: FlutterBinaryMessenger,
                      instanceName: String = "",
                      streamHandler: DeviceStateStreamHandler) {
    var channelName = "dev.flutter.pigeon.yucheng_ble.YuchengStreamApi.deviceState"
    if !instanceName.isEmpty {
      channelName += ".\(instanceName)"
    }
    let internalStreamHandler = PigeonStreamHandler<YuchengDeviceStateEvent>(wrapper: streamHandler)
    let channel = FlutterEventChannel(name: channelName, binaryMessenger: messenger, codec: yuchengBleApiPigeonMethodCodec)
    channel.setStreamHandler(internalStreamHandler)
  }
}
      
